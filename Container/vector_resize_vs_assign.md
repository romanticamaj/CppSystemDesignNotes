# std::vector: resize() vs. assign() 深度比較

## 1. 核心概念與行為

在 C++ `std::vector` 中，`resize()` 和 `assign()` 都能改變容器的元素數量，但它們的設計哲學和核心行為截然不同。

### 1.1. `resize()`: 保留與調整

`resize()` 的核心目的是 **調整容器大小，同時盡可能保留現有元素**。

- **擴展容器** (`new_size > size()`):

  - 保留所有現有元素。
  - 在尾部添加新元素，直到達到 `new_size`。
  - 新增的元素會被 **值初始化** (例如 `int` 為 0) 或使用提供的 `value` 進行 **複製構造**。

- **縮小容器** (`new_size < size()`):
  - 保留前 `new_size` 個元素。
  - 銷毀超出 `new_size` 範圍的元素。

```cpp
std::vector<int> vec = {1, 2, 3};

// 擴展：保留 {1, 2, 3}，並添加兩個值為 0 的元素
vec.resize(5); // vec is now {1, 2, 3, 0, 0}

// 縮小：只保留前兩個元素
vec.resize(2); // vec is now {1, 2}
```

### 1.2. `assign()`: 清除與重建

`assign()` 的核心目的是 **完全替換容器的內容**，不保留任何舊元素。

- **清除**：銷毀所有現有的元素。
- **重建**：根據提供的參數（指定數量的相同值、另一個容器的元素範圍或 `initializer_list`）重新構造新的元素。

```cpp
std::vector<int> vec = {1, 2, 3};

// 完全替換為 5 個值為 99 的元素
vec.assign(5, 99); // vec is now {99, 99, 99, 99, 99}

std::list<int> other = {4, 5, 6};
// 從另一個容器複製，完全替換
vec.assign(other.begin(), other.end()); // vec is now {4, 5, 6}
```

### 1.3. 關鍵行為對比

| 特性         | `resize()` (調整大小)        | `assign()` (完全替換)  |
| :----------- | :--------------------------- | :--------------------- |
| **核心行為** | **調整**現有內容             | **替換**所有內容       |
| **現有元素** | 在新大小範圍內 **保留**      | **全部銷毀**           |
| **元素構造** | 只構造 **新增** 的元素       | 重新構造 **所有** 元素 |
| **元素銷毀** | 只銷毀 **超出** 範圍的元素   | 銷毀 **所有** 舊元素   |
| **主要用途** | 動態調整緩衝區，增量數據處理 | 容器重置，從數據源複製 |

---

## 2. 內部實作深度解析

理解內部實作有助於掌握它們的性能和異常安全特性。

### 2.1. `resize()` 的實作策略

`resize()` 的實作遵循 **最小變動原則**。

1. **擴展 (`new_size > size()`)**:
   - **容量檢查**: 如果 `new_size > capacity()`，則需要重新分配內存。這是一個昂貴的操作，會將所有現有元素移動到新的內存區域。
   - **構造新元素**: 在現有元素的末尾，使用值初始化或提供的副本來構造新元素。
2. **縮小 (`new_size < size()`)**:
   - **銷毀多餘元素**: 直接在原內存上銷毀從 `new_size` 到 `size()` 的元素。
   - **容量不變**: `capacity()` 通常不會改變，保留的內存可供未來擴展使用。

### 2.2. `assign()` 的實作策略

`assign()` 的實作是 **破壞後重建**。

1. **銷毀舊元素**: 首先調用所有現有元素的析構函數，清空容器。
2. **容量判斷**:
   - **容量足夠 (`count <= capacity()`)**: 在現有內存上直接構造 `count` 個新元素。這避免了內存重新分配，但仍需銷毀和構造。
   - **容量不足 (`count > capacity()`)**: 釋放舊內存，分配一塊足夠大的新內存，然後在新內存上構造 `count` 個元素。

### 2.3. 實作差異總結

| 實作層面     | `resize()`                         | `assign()`                           |
| :----------- | :--------------------------------- | :----------------------------------- |
| **內存策略** | **保守型**：盡力重用並保留現有內存 | **激進型**：若容量不足則果斷重新分配 |
| **元素處理** | **增量式**：只處理變動的部分       | **批量式**：總是處理所有元素         |
| **緩存影響** | 擴展時局部性好，縮小時不變         | 可能因重新分配導致緩存失效           |
| **優化方向** | 針對 **部分修改** 進行優化         | 針對 **批量操作** 進行優化           |

---

## 3. 性能與異常安全

### 3.1. 性能考量

- **`resize()` 的性能優勢**:

  - 當 **保留數據** 且僅做少量擴展或縮小時，性能遠高於 `assign()`，因為它避免了不必要的元素銷毀和構造。
  - 如果預先使用 `reserve()` 分配了足夠的容量，擴展操作將非常快。

- **`assign()` 的性能考量**:
  - 總開銷與 **新元素數量** 成正比，因為它總是重新構造所有元素。
  - 對於 `trivially copyable` 類型，編譯器可能將其優化為 `memcpy` 或 `memmove`，此時性能極高。

**結論**：性能選擇取決於意圖。需要保留數據時，`resize()` 是不二之選。需要完全重置時，`assign()` 更直接，且對簡單類型的優化更好。

### 3.2. 異常安全保證

- **`resize(new_size)`**:

  - **強異常安全保證 (Strong Exception Guarantee)**。
  - 如果在擴展過程中，元素構造函數拋出異常，`vector` 的狀態會回滾到調用 `resize()` 之前的狀態，**不會有任何數據丟失或狀態損壞**。

- **`assign()`**:
  - **基本異常安全保證 (Basic Exception Guarantee)**。
  - 如果在賦值過程中拋出異常，**原容器的數據已全部丟失**，但程序仍處於有效狀態（容器為空或處於某個有效的中間狀態），不會內存洩漏。
  - 為了在 `assign` 中實現強異常安全，可以藉助 "copy-and-swap" 模式。

---

## 4. 應用場景與最佳實踐

### 4.1. 何時使用 `resize()`

**核心原則：當你需要保留現有數據時。**

- **動態緩衝區**: 網絡或音訊緩衝區，需要根據數據量動態調整大小。
- **預分配與填充**: `vector` 作為數組使用，先 `resize` 到目標大小，再通過索引訪問。
- **增量處理**: 處理數據流時，逐步擴大容器以容納新數據。

```cpp
// 場景：預先創建N個對象以供後續使用
std::vector<MyObject> objects;
objects.resize(100); // 創建 100 個默認構造的 MyObject

for(int i = 0; i < 100; ++i) {
    objects[i].initialize(i); // 後續初始化
}
```

### 4.2. 何時使用 `assign()`

**核心原則：當你需要完全重置容器內容時。**

- **狀態重置**: 在遊戲或模擬中，重置對象池或場景數據。
- **數據複製**: 從 `array`, `list` 或其他數據源完全複製內容。
- **清空並填充**: 需要用全新的、統一的數據替換所有舊數據。

```cpp
// 場景：從一個C風格數組重置vector
int c_array[] = {1, 1, 2, 3, 5, 8};
std::vector<int> fib_vec;
fib_vec.assign(c_array, c_array + 6);
```

### 4.3. 常見陷阱與優化技巧

- **陷阱 1：誤用 `resize` 進行填充**

  ```cpp
  std::vector<int> vec = {1, 2, 3, 4, 5};
  // 錯誤意圖：想用3個99替換內容
  vec.resize(3, 99); // 結果是 {1, 2, 3}，99 未被使用
  // 正確做法：
  vec.assign(3, 99); // 結果是 {99, 99, 99}
  ```

- **陷阱 2：誤用 `assign` 擴展容器**

  ```cpp
  std::vector<int> vec = {1, 2, 3};
  // 錯誤意圖：想保留數據並擴展
  vec.assign(5, 0); // 結果是 {0, 0, 0, 0, 0}，原始數據丟失
  // 正確做法：
  vec.resize(5, 0); // 結果是 {1, 2, 3, 0, 0}
  ```

- **優化技巧：結合 `clear()` 和 `reserve()`**
  如果需要清空 `vector` 但保留其內存容量以備後用（避免重新分配），可以使用 `clear()` 而不是 `resize(0)`。

  ```cpp
  std::vector<int> vec;
  vec.reserve(1000);
  // ... 填充數據 ...
  vec.clear(); // size() 變為 0，但 capacity() 仍然是 1000
  ```

---

## 5. 總結

|          | `resize()`          | `assign()`         |
| :------- | :------------------ | :----------------- |
| **哲學** | **調整** (Adjust)   | **替換** (Replace) |
| **數據** | **保留** (Preserve) | **銷毀** (Destroy) |
| **性能** | 保留數據時高效      | 重置數據時高效     |
| **安全** | 強異常安全          | 基本異常安全       |

選擇 `resize()` 還是 `assign()` 取決於你的 **意圖**。理解它們的根本差異是編寫高效、安全且意圖明確的 C++ 代碼的關鍵。
