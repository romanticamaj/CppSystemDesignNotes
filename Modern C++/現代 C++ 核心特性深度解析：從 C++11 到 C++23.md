# **現代 C++ 核心特性深度解析：從 C++11 到 C++23**

## **第一部分：類型系統與編譯期計算的革命**

本報告的第一部分旨在探討 C++11 引入並在後續標準中不斷完善的基礎性變革。這些變革將大量的計算與類型相關的負擔從開發者（以及執行期）轉移到了編譯器，代表了現代 C++ 在哲學層面最重大的演進。

### **第一節：現代類型推導**

本節將探討構成現代 C++ 類型推導基石的工具，從簡單的類型推斷，到泛型程式設計與元編程所需之精確控制。

#### **1.1 auto：從初始化式進行類型推導**

**核心概念**

C++11 引入的 auto 關鍵字，作為一個類型佔位符，指示編譯器從變數的初始化表達式中自動推導其確切類型 1。此特性的主要優勢在於大幅減少了程式碼的冗餘，尤其是在處理複雜類型時，例如標準模板庫（STL）的迭代器或複雜的模板類型。使用

auto 不僅能讓程式碼更簡潔，更能提升其健壯性：當初始化表達式的類型發生變化時（例如，函數返回類型被修改），使用 auto 的程式碼無需修改即可自動適應 1。

**推導規則**

auto 的類型推導遵循模板參數推導的規則，而非 decltype 的規則 4。這意味著

auto 通常會對類型進行「衰變」（decay）。具體來說，推導過程中會忽略引用（references）以及頂層的 const 和 volatile 限定符 3。

**實作範例：引用處理**

為了清晰地展示 auto 的推導規則，以下範例呈現了一個返回引用的函數。即使函數返回的是引用類型，auto 預設仍會推導出一個值類型。若要獲取引用，必須明確使用 auto& 或 auto&&。

```cpp
#include <iostream>

// 此函數返回一個全域變數的全域左值引用
int& get_global_value() {
    static int global_val = 10;
    return global_val;
}

int main() {
    // auto 推導：x 的類型是 int，而非 int&。
    // get_global_value() 返回的引用被「衰變」為值。
    auto x = get_global_value();

    // auto& 推導：y 的類型是 int&，它是一個指向 global_val 的引用。
    auto& y = get_global_value();

    std::cout << "Initial values: x = " << x << ", y = " << y << std::endl;

    // 修改 x 只會影響其本地副本
    x = 20;
    std::cout << "After modifying x: x = " << x << ", y = " << y << std::endl;

    // 修改 y 會透過引用影響原始的全域變數
    y = 30;
    std::cout << "After modifying y: x = " << x << ", y = " << y << std::endl;

    // 再次呼叫函數以驗證全域變數的確被修改
    std::cout << "Value from get_global_value(): " << get_global_value() << std::endl;

    return 0;
}
```

此範例的輸出將會是：

```
Initial values: x = 10, y = 10
After modifying x: x = 20, y = 10
After modifying y: x = 20, y = 30
Value from get_global_value(): 30
```

從輸出中可以清楚看到，x 僅僅是 global_val 的一個副本，而 y 則是對 global_val 的引用，因此對 y 的修改會影響原始變數 3。

**強制初始化**

auto 的一個關鍵安全優勢在於它強制變數在宣告時必須被初始化 2。由於類型推導依賴於初始化表達式，因此不可能宣告一個未初始化的

auto 變數。這從根本上消除了一整類常見的程式錯誤，即因忘記初始化而導致的未定義行為。

#### **1.2 decltype：檢驗表達式的確切類型**

**核心概念**

decltype 是 C++11 引入的一個運算子，其功能是產生一個實體（entity）或表達式（expression）的「宣告類型」（declared type），而不會實際對該表達式進行求值 7。這與

sizeof 運算子相似，其運算元也是在未求值上下文中處理 4。與

auto 基於初始化式推導類型不同，decltype 直接作用於表達式本身 6。它的主要應用場景是在泛型程式碼中，尤其是模板程式庫，其中類型依賴於模板參數，難以或無法預先確定 7。

**decltype 的雙重面貌**

decltype(e) 的推導規則極其精確，但其行為根據表達式 e 的形式而有所不同，這種雙重性是其強大之處，也是初學者的困惑之源。

1.  **「變數 decltype」（Variable decltype）**：此行為類似於 lstat 系統呼叫，能夠窺探符號連結本身而非其指向的檔案。如果表達式 e 是一個「未加括號的標識符表達式」（unparenthesized id-expression），例如變數名 x，或是一個「未加括號的類別成員存取」（unparenthesized class member access），例如 a->x，那麼 decltype(e) 會產生該實體被宣告時的**確切類型** 7。
2.  **「表達式 decltype」（Expression decltype）**：此行為類似於 stat 系統呼叫，它會穿透符號連結，直接檢視檔案的屬性。對於任何其他形式的表達式 e，包括被括號包圍的標識符如 (x)，其推導結果將取決於該表達式的**值類別（value category）** 7。
    - 若 e 是**左值（lvalue）** 且類型為 T，則 decltype(e) 的結果是 T&（左值引用）。這解釋了為何 decltype(x) 是 int，而 decltype((x)) 卻是 int&，因為 (x) 是一個值類別為左值的表達式 7。
    - 若 e 是**xvalue** 且類型為 T，則 decltype(e) 的結果是 T&&（右值引用）7。
    - 若 e 是**純右值（prvalue）** 且類型為 T，則 decltype(e) 的結果是 T 7。

**實作範例**

以下程式碼清晰地展示了 decltype 的各種推導規則：

```cpp
#include <iostream>
#include <utility> // for std::move

struct A { double x; };
const A* a_ptr = new A();

int i = 42;
int& r = i;
int&& rr = 42;

int get_val() { return 0; }
int& get_lval_ref() { return i; }
int&& get_rval_ref() { return 42; }

int main() {
    // 規則 1: 未加括號的標識符表達式
    decltype(i) var1; // var1 的類型是 int
    decltype(r) var2 = i; // var2 的類型是 int&
    decltype(rr) var3 = 42; // var3 的類型是 int&&
    decltype(a_ptr->x) var4; // var4 的類型是 double (類別成員存取)

    // 規則 2: 基於值類別的表達式推導
    // (i) 是左值表達式
    decltype((i)) lvalue_ref = i; // lvalue_ref 的類型是 int&

    // std::move(i) 是 xvalue 表達式
    decltype(std::move(i)) xvalue_ref = 42; // xvalue_ref 的類型是 int&&

    // get_val() 是 prvalue 表達式
    decltype(get_val()) prvalue_val; // prvalue_val 的類型是 int

    // 函數呼叫表達式
    decltype(get_lval_ref()) lval_func_ref = i; // 返回左值引用的函數，表達式為左值，類型為 int&
    decltype(get_rval_ref()) rval_func_ref = 42; // 返回右值引用的函數，表達式為xvalue，類型為 int&&

    std::cout << "decltype(i) is int: " << std::is_same_v<decltype(var1), int> << std::endl;
    std::cout << "decltype((i)) is int&: " << std::is_same_v<decltype(lvalue_ref), int&> << std::endl;
    std::cout << "decltype(std::move(i)) is int&&: " << std::is_same_v<decltype(xvalue_ref), int&&> << std::endl;
    std::cout << "decltype(get_val()) is int: " << std::is_same_v<decltype(prvalue_val), int> << std::endl;

    delete a_ptr;
    return 0;
}
```

這個範例的輸出將驗證上述規則，顯示 decltype 如何根據表達式的形式和值類別精確地推導類型。

值類別（value categories）的概念，如左值、純右值和 xvalue，隨著 decltype 和右值引用的引入，從一個純粹的語言理論話題，轉變為高階開發者日常工作中必須面對的實際問題。理解 decltype(x) 和 decltype((x)) 之間的細微差別，對於編寫正確的泛型程式碼至關重要，因為它直接影響到類型是被推導為值還是引用 7。

decltype 因此成為了一個強大的編譯期工具，用於檢查和推斷這些值類別。

#### **1.3 decltype(auto)：為完美返回類型轉發統一類型推導**

**核心概念**

C++14 引入的 decltype(auto) 是一種獨特的類型推導模式，它並非 decltype 和 auto 的簡單組合 11。當用於變數宣告或函數返回類型時，它會使用

decltype 的規則應用於其初始化式或返回表達式，從而推導出確切的類型 11。

**解決的問題**

decltype(auto) 的核心價值在於實現了「返回值的完美轉發」（perfect forwarding for return values）11。在泛型程式設計中，一個常見的需求是編寫一個包裝函數（wrapper function），該函數應準確返回被包裝函數的返回值，包括其值類別（即，如果內部函數返回引用，包裝函數也應返回引用）。

在 C++11 中，這個問題不易解決：

- 使用 auto 作為返回類型會失敗，因為 auto 遵循模板推導規則，會將引用「衰變」為值類型 5。
- 使用帶有 decltype 的尾隨返回類型（trailing return type），如 auto func() -> decltype(expression)，雖然可行，但語法冗長，且需要在簽名中重複返回表達式，增加了出錯的可能 5。

decltype(auto) 正是為了解決這個困境而生。它指示編譯器直接將 decltype 的規則應用於 return 語句中的表達式，從而簡潔地保留了返回值的確切類型，包括其引用屬性 12。這一演進清晰地展示了 C++ 標準委員會的迭代設計過程：C++11 提供了強大但分散的工具，而 C++14 則針對一個關鍵用例（返回類型轉發）提供了一個更優雅、更精確的綜合性解決方案。

**實作範例：包裝函數**

以下範例展示了一個泛型函數 authAndAccess，它模擬了在存取容器元素前進行身份驗證的場景。容器的下標運算子 operator[] 通常返回一個引用。

```cpp
#include <iostream>
#include <vector>
#include <string>

// 模擬一個返回引用的容器
template<typename T>
struct ContainerWrapper {
    std::vector<T> data;
    T& operator[](size_t index) {
        return data[index];
    }
};

// 版本 1: 使用 auto，錯誤地衰變了引用
template<typename Container, typename Index>
auto authAndAccess_auto(Container& c, Index i) {
    // 假設這裡有身份驗證邏輯
    return c[i];
}

// 版本 2: 使用 decltype(auto)，正確地保留了引用
template<typename Container, typename Index>
decltype(auto) authAndAccess_decltype_auto(Container& c, Index i) {
    // 假設這裡有身份驗證邏輯
    return c[i];
}

int main() {
    ContainerWrapper<int> c;
    c.data = {10, 20, 30};

    // 使用 auto 的版本
    auto val = authAndAccess_auto(c, 1);
    val = 99; // 只修改了本地副本 val，c 中的元素不變
    std::cout << "After authAndAccess_auto, c[1] = " << c.data[1] << std::endl; // 輸出 20

    // 使用 decltype(auto) 的版本
    decltype(auto) ref = authAndAccess_decltype_auto(c, 1);
    ref = 99; // 修改了 ref，它是一個引用，因此 c 中的元素被改變
    std::cout << "After authAndAccess_decltype_auto, c[1] = " << c.data[1] << std::endl; // 輸出 99

    // --- 演示 decltype 的細微之處 ---
    int local_var = 5;
    // return local_var; -> decltype(local_var) -> int
    // return (local_var); -> decltype((local_var)) -> int&
    // 這解釋了為何在泛型程式碼中，返回表達式的形式至關重要

    return 0;
}
```

在這個範例中，authAndAccess_auto 因為使用了 auto，其返回類型被推導為 int，導致對返回值的修改不會影響容器內的原始資料。相反，authAndAccess_decltype_auto 正確地推導返回類型為 int&，使得調用者可以透過返回的引用修改容器中的元素，這才是完美的轉發行為 11。

此外，值得注意的是 decltype(auto) 的行為與 return 後面的表達式形式密切相關。例如，return i; 會被 decltype 視為變數名，推導為 int；而 return (i); 則被視為左值表達式，推導為 int& 10。這個細節對於編寫依賴

decltype(auto) 的泛型程式碼至關重要。

#### **1.4 std::declval：用於未求值上下文的元編程工具**

**核心概念**

std::declval<T>() 是一個定義於 <utility> 標頭檔的函數模板，它返回類型 T 的右值引用（T&&）。其最關鍵的特性是：它**只能**在不被求值的上下文（unevaluated contexts）中使用，例如作為 decltype、sizeof 或 noexcept 的運算元 16。

std::declval 的存在讓我們可以在編譯期「假裝」擁有一個類型為 T 的物件，以便檢查對該物件進行某些操作的有效性或結果類型，而無需實際創建該物件的實例。

**解決的問題**

在模板元編程中，我們經常需要推斷某個操作的結果類型，而這個操作依賴於模板參數 T。如果 T 沒有預設建構函式，或者其建構函式是私有的，我們就無法在 decltype 中創建一個 T 的臨時物件來進行類型推導 16。

std::declval 完美地解決了這個問題，它允許我們在不呼叫任何建構函式的情況下，獲得一個代表 T 型別物件的表達式 18。

**實作範例：泛型 sum_t**

以下範例展示了如何定義一個泛型類型別名 sum_t，用於推導任意兩個類型 T 和 U 相加後的結果類型。

```cpp
#include <iostream>
#include <utility> // for std::declval
#include <type_traits> // for std::is_same_v

// 一個沒有預設建構函式的類別
struct NonDefaultConstructible {
    NonDefaultConstructible(int) {} // 只有一個帶參數的建構函式
};

// 重載 operator+
int operator+(const NonDefaultConstructible&, int) {
    return 0;
}

// 使用 std::declval 的正確實作
template<typename T, typename U>
using sum_t = decltype(std::declval<T>() + std::declval<U>());

int main() {
    // 測試基本類型
    using type1 = sum_t<int, double>;
    std::cout << "sum_t<int, double> is double: "
              << std::is_same_v<type1, double> << std::endl;

    // 嘗試推導涉及 NonDefaultConstructible 的類型
    using type2 = sum_t<NonDefaultConstructible, int>;
    std::cout << "sum_t<NonDefaultConstructible, int> is int: "
              << std::is_same_v<type2, int> << std::endl;

    // 如果沒有 std::declval，以下程式碼將無法編譯
    /*
    template<typename T, typename U>
    using failing_sum_t = decltype(T{} + U{});

    // 編譯錯誤：NonDefaultConstructible 沒有預設建構函式
    // using type3 = failing_sum_t<NonDefaultConstructible, int>;
    */

    return 0;
}
```

在這個範例中，sum_t 成功地推導出 int 和 double 相加的結果為 double。更重要的是，它也成功推導出 NonDefaultConstructible 和 int 相加的結果為 int，儘管我們無法輕易地創建 NonDefaultConstructible 的實例 9。如果我們嘗試使用

T{} 來創建一個臨時物件，編譯將會因為 NonDefaultConstructible 沒有預設建構函式而失敗 16。

std::declval 因此成為了模板元編程中不可或缺的工具。

### **第二節：編譯期程式設計的擴展**

本節詳細介紹 C++ 語言的演進，這些特性允許程式碼在編譯階段執行，從而帶來顯著的性能提升、增強的類型安全以及更具表達力的 API。

#### **2.1 constexpr：從 C++11 到 C++14 及以後**

**核心概念**

constexpr 說明符（specifier）宣告了一個變數的值或一個函數的結果**有可能**在編譯期被求值 20。被

constexpr 修飾的實體可以用於需要常數表達式的上下文中，例如陣列邊界、模板的非類型參數或 static_assert 21。

**C++11 的規則**

在 C++11 中，constexpr 函數的功能受到嚴格限制。它們的函數體基本上只能包含一個 return 語句。不允許宣告區域變數、不允許使用迴圈，且只能呼叫其他的 constexpr 函數 21。這些限制使得編寫複雜的編譯期演算法變得困難，通常需要依賴遞迴。

**C++14 的放寬**

C++14 大幅放寬了對 constexpr 函數的限制，使其變得更加強大和實用。C++14 的 constexpr 函數中可以包含：

- 區域變數宣告（但不能是 static 或 thread_local）。
- 大部分的控制流程語句，包括 if、switch、for、while 和 do-while 迴圈。
- 多個 return 語句。

這些放寬使得在編譯期編寫傳統的命令式風格演算法成為可能 21。

**實作範例：階乘函數**

以下範例透過計算階乘的函數，清晰地展示了 C++11 和 C++14 constexpr 之間的差異。

```cpp
#include <iostream>

// C++11 風格的 constexpr 階乘函數 (使用遞迴)
constexpr int factorial_cpp11(int n) {
    return n <= 1 ? 1 : n * factorial_cpp11(n - 1);
}

// C++14 風格的 constexpr 階乘函數 (使用迴圈和區域變數)
constexpr int factorial_cpp14(int n) {
    int result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
    }
    return result;
}

int main() {
    // 在編譯期驗證
    static_assert(factorial_cpp11(5) == 120, "C++11 factorial failed");
    static_assert(factorial_cpp14(5) == 120, "C++14 factorial failed");

    // 在執行期使用
    int num = 6;
    std::cout << "Factorial of 6 (C++11 style): " << factorial_cpp11(num) << std::endl;
    std::cout << "Factorial of 6 (C++14 style): " << factorial_cpp14(num) << std::endl;

    return 0;
}
```

factorial_cpp11 函數展示了 C++11 的限制，只能透過遞迴和三元運算子來實現。而 factorial_cpp14 函數則使用了迴圈和區域變數 result，這種寫法在 C++11 中是不合法的，但在 C++14 中則完全有效 25。這清晰地表明 C++14

constexpr 在表達能力上的巨大飛躍。

#### **2.2 consteval 與 constinit (C++20)：強制編譯期保證**

隨著 constexpr 的普及，開發者需要更精確的工具來控制編譯期行為。C++20 引入了 consteval 和 constinit，提供了比 constexpr 更強的保證。

**consteval（立即函數）**

consteval 說明符比 constexpr 更嚴格。它宣告一個「立即函數」（immediate function），這意味著該函數**必須**在編譯期被求值。任何在執行期呼叫 consteval 函數的嘗試都會導致編譯錯誤 26。這對於那些只在編譯期有意義的函數（例如，用於程式碼產生、解析格式化字串或靜態反射的工具）至關重要。

**constinit（常數初始化）**

constinit 說明符提供的是關於**初始化**的保證，而非**常數性**。它斷言一個具有靜態儲存期（static storage duration）或執行緒儲存期（thread storage duration）的變數必須進行常數初始化（即在編譯期完成初始化）。這個特性旨在解決長期困擾 C++ 的「靜態初始化順序災難」（static initialization order fiasco）28。與

constexpr 變數不同，一個 constinit 變數在完成編譯期初始化後，其值在執行期是可以被修改的 28。

**實作範例**

```cpp
#include <iostream>
#include <string_view>

// consteval 範例：一個必須在編譯期執行的函數
consteval int parse_value(std::string_view sv) {
    if (sv == "high") return 100;
    if (sv == "low") return 10;
    return 0;
}

// constinit 範例：保證全域變數在編譯期初始化
// 這個 logger 在程式啟動前就已準備好，但其狀態可在執行期改變
struct Logger {
    int level;
    void set_level(int new_level) { level = new_level; }
};

constinit Logger g_logger = { parse_value("high") }; // OK，在編譯期初始化

int main() {
    // 使用 consteval 函數
    constexpr int high_val = parse_value("high"); // OK
    // int runtime_val = 5;
    // parse_value(std::to_string(runtime_val)); // 編譯錯誤：consteval 函數不能在執行期呼叫

    // 使用 constinit 變數
    std::cout << "Initial logger level: " << g_logger.level << std::endl;
    g_logger.set_level(parse_value("low")); // OK，在執行期修改 constinit 變數
    std::cout << "Updated logger level: " << g_logger.level << std::endl;

    return 0;
}
```

#### **2.3 編譯期控制流程：if constexpr 與 if consteval**

**if constexpr (C++17)**

此結構在編譯期對其條件進行求值。如果條件為 true，則編譯 then 區塊，並**丟棄** else 區塊（反之亦然）。被丟棄的區塊不會被實例化，因此其語法對於給定的模板參數無需有效 31。這是在函數體內進行條件式編譯的巨大進步，遠優於 SFINAE 技術。

**if consteval (C++23)**

此結構檢查當前的求值是否發生在一個常數求值上下文中。它專門為了解決從 constexpr 函數內部呼叫 consteval 函數的問題而設計。constexpr 函數可能在執行期被呼叫，但 consteval 函數不能。if consteval 允許 constexpr 函數進行分支，僅在它本身於編譯期被求值時才呼叫 consteval 函數 32。

值得注意的是，if constexpr (std::is_constant_evaluated()) 並不能替代 if consteval。前者在 constexpr 上下文中總是求值為 true，使其不適用於根據*呼叫者*的上下文進行分支 33。

**實作範例**

```cpp
#include <iostream>
#include <type_traits>

consteval int compile_time_func() { return 1; }
int runtime_func() { return 2; }

constexpr int chooser() {
    if consteval {
        return compile_time_func(); // 當 chooser() 在編譯期被呼叫時執行
    }
    else {
        return runtime_func(); // 當 chooser() 在執行期被呼叫時執行
    }
}

int main() {
    constexpr int val1 = chooser(); // 呼叫 compile_time_func()
    int val2 = chooser(); // 呼叫 runtime_func()

    std::cout << "Compile-time result: " << val1 << std::endl; // 輸出 1
    std::cout << "Run-time result: " << val2 << std::endl;     // 輸出 2

    static_assert(val1 == 1);

    return 0;
}
```

這個範例展示了 chooser 函數如何根據其自身的求值上下文（編譯期或執行期）來選擇呼叫哪個內部函數，這正是 if consteval 的設計初衷 32。

從 C++11 限制性的 constexpr 到 C++20 強大的 consteval 及 if constexpr 等控制流結構的演進，揭示了一個清晰的趨勢：C++ 如今擁有一個穩健且圖靈完備的子語言，它在編譯期間執行。這不僅僅是為了簡單的常數計算，更是為了元編程、靜態反射以及基於類型屬性生成高度優化的專用程式碼。constinit 的出現則是對 C++ 長期存在問題的現代化、語言級別的直接解決方案，反映出現代 C++ 將經過驗證的模式提升為明確語言特性的趨勢，以增強安全性與清晰度。

#### **表格 2.1：編譯期關鍵字比較**

| 說明符 (Specifier) | 求值時間 (Evaluation Time) | 不可變性 (Immutability) | 適用範圍 (Scope)   | 主要用途                     |
| :----------------- | :------------------------- | :---------------------- | :----------------- | :--------------------------- |
| const              | 執行期 (Runtime)           | 是                      | 任何範圍           | 執行期不可變性               |
| constexpr (變數)   | 編譯期 (Compile-time)      | 是                      | 任何範圍           | 編譯期常數變數               |
| constexpr (函數)   | 編譯期或執行期             | 否                      | 命名空間、類別     | 可在編譯期或執行期使用的函數 |
| consteval (函數)   | 編譯期 (Compile-time)      | 否                      | 命名空間、類別     | 必須在編譯期執行的函數       |
| constinit (變數)   | 編譯期 (Compile-time)      | 否                      | 靜態或執行緒儲存期 | 強制變數在編譯期初始化       |

此表格總結了各關鍵字的 subtle 差異，為開發者選擇正確的編譯期說明符提供了清晰的參考 20。

## **第二部分：高階模板程式設計與約束**

本部分從通用的編譯期特性過渡到它們在 C++ 最強大也最複雜的領域——模板元編程中的具體應用。它描繪了從晦澀、易錯的技術到現代、具表達力且安全的約束系統的演進歷程。

### **第三節：<type_traits> 函式庫：元編程的基石**

本節涵蓋 <type_traits> 標頭檔中的核心工具，這些工具允許程式碼在編譯期檢查和轉換類型。它們是 SFINAE、Concepts 以及其他高階泛型程式設計技術的基礎構件。

#### **3.1 概覽：類別、屬性與關係**

**核心概念**

<type_traits> 標頭檔提供了一系列模板結構，它們透過成員常數（如 ::value）或成員類型（如 ::type）來揭示類型的編譯期資訊 34。自 C++14/17 起，輔助變數模板（

\_v）和別名模板（\_t）提供了更簡潔的語法，使得這些工具的使用更加方便 34。

**分類**

這些 traits 可以被邏輯地分組，以便於理解和使用 35：

- **類型類別檢查 (Type Category Checks)**：判斷類型是否為指標、陣列、類別、整數等。例如 is_integral、is_pointer、is_class、is_aggregate (C++17) 38、
  is_bounded_array (C++20) 39。
- **類型屬性查詢 (Type Property Queries)**：查詢類型是否具有某種性質。例如 is_const、is_trivial、is_trivially_copyable 35。
- **類型關係 (Type Relationships)**：檢視兩個類型之間的關係。例如 is_same、is_base_of、is_convertible、is_layout_compatible (C++20) 35。
- **類型轉換 (Type Transformations)**：透過修改現有類型來創建新類型。例如 add_const、remove_reference 35。

#### **3.2 關鍵轉換 Traits 深度剖析**

- **std::remove_reference**：從一個引用類型中創建其非引用類型。T& 和 T&& 都會變成 T，而 const T& 則變成 const T。它只移除引用，不影響其他限定符 42。
- **std::remove_cvref (C++20)**：這是一個方便的 trait，結合了 std::remove_cv 和 std::remove_reference 的功能。例如，const volatile T& 會變成 T。它簡化了一個非常常見的元編程模式 44。
- **std::decay**：執行當按值傳遞參數時發生的類型轉換：移除引用、移除頂層的 cv 限定符，並將陣列/函數類型轉換為指標 46。這對於在泛型包裝器（如
  std::tuple 或 std::optional）中儲存參數副本至關重要。一個實用的例子將展示在何種情況下 std::decay 是必需的，而 std::remove_reference 則不足以應對（例如，儲存一個 C 風格陣列）46。
- **std::conditional**：編譯期的三元運算子。std::conditional<B, T, F>::type 在布林常數 B 為 true 時產生類型 T，否則產生類型 F 48。
- **std::common_type**：確定一組類型都可以被轉換成的共同類型。這對於編寫需要優雅處理混合模式類型的泛型算術運算子或函數至關重要 50。

#### **3.3 std::invoke_result：推導可呼叫物件的調用結果**

**核心概念**

std::invoke_result<F, Args...>::type（及其 \_t 輔助模板）用於確定使用泛化的 INVOKE 操作來調用一個可呼叫物件（Callable）F 並傳遞參數 Args... 時的返回類型 52。

**對 std::result_of 的改進**

std::result_of 在 C++17 中被棄用，並在 C++20 中被移除。invoke_result 之所以更優越，是因為它能正確處理更廣泛的可呼叫物件，包括成員函數指標和資料成員指標，與 std::invoke 的行為保持一致 54。相比之下，

result_of 使用了奇特的 F(Args...) 語法，且行為不夠一致 52。

**實作範例**

以下範例展示了一個模板函數，它接受一個泛型可呼叫物件和一些參數，並需要宣告一個變數來儲存結果。此範例將展示 std::invoke_result_t 如何處理普通函數、lambda 和成員函數指標，突顯其通用性。

```cpp
#include <iostream>
#include <functional> // for std::invoke
#include <type_traits> // for std::invoke_result_t, std::is_same_v

// 範例函數和類別
int regular_function(int x) { return x * 2; }
struct MyClass {
    int member_variable = 10;
    int member_function(int y) { return member_variable + y; }
};

template<typename Callable, typename... Args>
void call_and_store(Callable&& func, Args&&... args) {
    // 使用 invoke_result_t 推導返回類型
    using result_type = std::invoke_result_t<Callable, Args...>;

    // 呼叫並儲存結果
    result_type result = std::invoke(std::forward<Callable>(func), std::forward<Args>(args)...);

    std::cout << "Result: " << result << ". ";
    std::cout << "Deduced type is int: " << std::is_same_v<result_type, int> << std::endl;
}

int main() {
    // 1. 測試普通函數
    call_and_store(regular_function, 5);

    // 2. 測試 Lambda
    auto lambda = (double d) -> int { return static_cast<int>(d); };
    call_and_store(lambda, 7.5);

    // 3. 測試成員函數指標
    MyClass obj;
    call_and_store(&MyClass::member_function, obj, 20);

    // 4. 測試資料成員指標 (C++17 invoke_result 可以處理，但 result_of 不行)
    using member_var_type = std::invoke_result_t<decltype(&MyClass::member_variable), MyClass&>;
    member_var_type var = std::invoke(&MyClass::member_variable, obj);
    std::cout << "Member variable: " << var << ". ";
    std::cout << "Deduced type is int: " << std::is_same_v<member_var_type, int> << std::endl;

    return 0;
}
```

<type_traits> 函式庫不僅僅是一個工具集，它是 C++ 類型系統向使用者程式碼的根本性延伸。它提供了進行編譯期內省和操作所必需的詞彙（如 is_integral、remove_reference），這些是現代泛型程式設計的先決條件。而 std::decay 的存在揭示了 C++ 中的一個深層原則：一個類型作為**介面**和作為**儲存機制**之間的區別。當按值傳遞參數或將其儲存在容器中時，我們幾乎總是想要一個「衰變」後的版本——一個純粹的值，這就是 std::decay 的核心價值所在 46。

### **第四節：從 SFINAE 到 Concepts：模板約束的演進**

本節記錄了在約束模板方面的範式轉移，從一個「意外」的語言特性（SFINAE）演進到一個現代、具表達力且安全的系統（Concepts）。

#### **4.1 SFINAE：經典的 std::enable_if 技術**

**核心概念**

SFINAE 是「替換失敗並非錯誤」（Substitution Failure Is Not An Error）的縮寫。這條規則指的是，在模板實例化過程中，如果將模板參數替換為實際類型時導致無效的類型或表達式，編譯器不會立即報錯，而是會靜默地將該重載候選從候選集中移除 56。

**std::enable_if 作為引擎**

std::enable_if<Condition, T>::type 是利用 SFINAE 的主要工具。如果布林常數 Condition 為 true，enable_if 會產生一個名為 type 的成員類型（其類型為 T）；否則，enable_if 將沒有 type 成員，導致對 ::type 的存取替換失敗，從而「SFINAE-out」該重載 59。

**常見模式**

以下範例展示了如何使用 enable_if 作為返回類型，將一個模板函數約束為僅接受整數類型。

```cpp
#include <iostream>
#include <type_traits>

// 僅對整數類型啟用此模板
template<typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
add_one(T val) {
    std::cout << "Integral version called: ";
    return val + 1;
}

// 僅對浮點數類型啟用此模板
template<typename T>
typename std::enable_if<std::is_floating_point<T>::value, T>::type
add_one(T val) {
    std::cout << "Floating point version called: ";
    return val + 1.0;
}

int main() {
    std::cout << add_one(5) << std::endl; // 呼叫整數版本
    std::cout << add_one(3.14) << std::endl; // 呼叫浮點數版本
    // add_one("hello"); // 編譯錯誤，沒有匹配的重載
    return 0;
}
```

此方法雖然有效，但其語法冗長且難以閱讀，且當約束失敗時，編譯器產生的錯誤訊息通常極為冗長，難以理解，這正是 SFINAE 的主要缺點 56。

#### **4.2 C++20 Concepts：一個更優越的範式**

**核心概念**

concept 是一個命名的需求集合，它以編譯期謂詞（predicate）的形式，對模板參數提出約束 62。Concepts 是 C++20 引入的一等語言特性，旨在取代 SFINAE 作為約束模板的主要方式 56。

**相較於 SFINAE 的主要優勢**

- **清晰性與可讀性**：約束的意圖被直接且語義化地表達（例如 template<std::integral T>），而非透過晦澀的模板元編程技巧 64。
- **改進的錯誤訊息**：當約束不被滿足時，編譯器能夠根據 concept 的定義，提供簡潔且人類可讀的錯誤訊息 61。
- **重載解析**：Concepts 支援**包含關係（subsumption）**。如果一個 concept 是另一個 concept 的更嚴格版本（例如 BidirectionalIterator 包含了 ForwardIterator 的所有要求），編譯器能夠正確選擇更受約束的重載。而使用 SFINAE 時，這種情況常會導致模稜兩可的錯誤 66。
- **更廣泛的適用性**：Concepts 可以約束類別模板的非模板成員以及 auto 推導的類型，這些是 SFINAE 無法做到的 66。

#### **4.3 requires 關鍵字：子句與表達式**

**雙重含義**

requires 關鍵字有兩種截然不同的用途：引入一個 **requires-clause**（約束子句）和定義一個 **requires-expression**（約束表達式）68。

requires requires 這種看似奇怪的語法，正是這兩種用途結合的自然結果 68。

- **requires-clause**：出現在模板參數列表或函數簽名之後，用於施加約束。例如：template<typename T> void func(T t) requires std::integral<T>; 69。
- **requires-expression**：一個 bool 類型的常數表達式，用於定義 concept 的主體或作為一個即席的約束。它包含四種形式的需求 70：
  1.  **簡單需求 (Simple requirement)**：a + b;，斷言表達式是有效的。
  2.  **類型需求 (Type requirement)**：typename T::value_type;，斷言一個巢狀類型是有效的。
  3.  **複合需求 (Compound requirement)**：{\*a} -> std::convertible_to<int>;，斷言表達式的有效性、noexcept 保證以及返回類型的約束。
  4.  **巢狀需求 (Nested requirement)**：requires OtherConcept<T>;，斷言另一個約束被滿足。

#### **4.4 對比分析：SFINAE vs. Concepts**

以下透過一個泛型 product 函數來實際比較兩種方法的差異。

```cpp
#include <iostream>
#include <string>
#include <type_traits>
#include <concepts>

// --- SFINAE 版本 ---
template<typename T>
typename std::enable_if<std::is_arithmetic_v<T>, T>::type
product_sfinae(T a, T b) {
    return a * b;
}

// --- Concepts 版本 ---
template<typename T>
concept Multipliable = requires(T a, T b) {
    a * b;
};

template<Multipliable T>
T product_concepts(T a, T b) {
    return a * b;
}

int main() {
    // 兩種版本都能正常工作
    std::cout << "SFINAE (int): " << product_sfinae(3, 4) << std::endl;
    std::cout << "Concepts (double): " << product_concepts(2.5, 3.0) << std::endl;

    // 當傳入不支援 * 運算子的類型時
    // product_sfinae(std::string("a"), std::string("b")); // 編譯錯誤，訊息冗長
    // product_concepts(std::string("a"), std::string("b")); // 編譯錯誤，訊息清晰
}
```

當使用不相容的類型（如 std::string）呼叫時，SFINAE 版本的編譯器錯誤訊息通常會非常冗長，列出所有失敗的模板替換。而 Concepts 版本的錯誤訊息則會非常直接明瞭，指出 std::string 不滿足 Multipliable concept 的要求，因為 a \* b 表達式無效。

Concepts 不僅僅是 SFINAE 的替代品，它們是針對其根本缺陷（可讀性差、診斷訊息不佳）的直接、語言整合的解決方案 56。SFINAE 的約束是純句法的（例如「

T::type 是否存在？」），而 Concepts 鼓勵開發者從語義類別的角度思考（例如「T 是否為 Sortable？」），這是一種深刻的轉變，使模板程式設計從句法技巧的遊戲轉變為定義泛型類型語義介面的紀律化過程 62。

## **第三部分：現代 C++ 語言與函式庫特性巡禮**

本部分全面概述了其他重要的語言和函式庫特性，按時間和主題組織，以展示 C++ 在安全性、表達力和性能方面的持續演進。

### **第五節：核心語言的安全性與表達力增強**

本節涵蓋了從 C++11 到 C++17 的一系列核心語言特性，這些特性已成為現代 C++ 程式碼庫中不可或缺的部分。

#### **5.1 C++11 核心要素：現代 C++ 的基石**

- **nullptr**：一個類型安全的空指標常數，其類型為 std::nullptr_t。它解決了傳統上使用 NULL（通常是整數 0）在函數重載中可能引發的整數與指標之間的歧義問題 72。
- **static_assert**：編譯期斷言。如果其常數表達式為 false，編譯將會失敗並顯示使用者定義的錯誤訊息。這對於在編譯期驗證關於類型、大小和模板參數的假設至關重要 74。
- **override 與 final**：override 說明符確保一個衍生類別中的虛擬函數確實覆寫了基底類別的方法，從而防止因簽名不匹配而導致的潛在錯誤。final 說明符則阻止虛擬函數被進一步覆寫，或阻止一個類別被繼承 77。
- **預設與刪除函數 (= default, = delete)**：= default 明確要求編譯器產生特殊成員函數的預設版本。= delete 則禁止使用某個函數，為使類別不可複製或防止不期望的類型提升提供了更清晰的方法 79。
- **thread_local 儲存期**：宣告一個具有執行緒區域儲存期的變數。每個執行緒都會擁有該變數的獨立實例，該實例的生命週期與執行緒相同。這對於多執行緒程式設計中無需顯式鎖定即可維護每個執行緒的私有資料至關重要 82。
- **alignas 與 alignof**：alignas 用於指定類型或物件的自訂記憶體對齊方式，而 alignof 則用於查詢其對齊需求。這對性能敏感的程式碼，特別是 SIMD 操作，至關重要 85。
- **inline namespace**：一種使巢狀命名空間的成員看起來像是屬於其外層命名空間的機制。其主要用途是支援函式庫版本控制，允許 ABI 相容的演進而不會破壞使用者程式碼 89。

許多 C++11 特性，如 nullptr、override 和 =delete，都旨在讓編寫正確的程式碼變得更容易，而編寫錯誤的程式碼變得更困難。它們解決了 C++98 中普遍存在的常見且細微的錯誤。這反映了一種設計哲學，即透過使更安全的選項更加明確和顯而易見，來引導開發者進入「成功之坑」（pit of success）。

#### **5.2 C++14 增強功能：對 C++11 的精煉**

C++14 的主要目標是精煉和擴展 C++11 的功能，使其更易用、更強大。

- **泛型 Lambda**：允許在 lambda 參數列表 中使用 auto，有效地創建了一個帶有模板化 operator() 的函數物件。這使得單一的 lambda 能夠處理不同類型的參數 24。
- **二進位字面值**：引入了新的字面值前綴 0b 或 0B，用於以二進位形式指定整數常數，提高了位元遮罩和硬體相關程式碼的可讀性 94。

#### **5.3 C++17 里程碑：可用性的大幅躍進**

C++17 帶來了多項顯著提升開發效率和程式碼清晰度的特性。

- **結構化綁定 (Structured Bindings)**：提供了一種便捷的語法，可以將 struct、pair、tuple 或陣列的元素解包到具名變數中。這在處理返回多個值的函數時，極大地提高了程式碼的可讀性 97。
- **if constexpr**：此特性在第二節中已有詳細討論，此處再次提及是為了強調其作為 C++17 一項重大語言可用性特性的地位，它極大地簡化了以往需要複雜 SFINAE 技巧才能實現的條件式編譯。

C++ 標準的演進呈現出一種革命與精煉的循環模式。C++11 是一場革命，引入了大量新範式。C++14 則主要是精煉，使 C++11 的特性（如 constexpr 和 lambda）更強大、更易用。C++17 則是可用性上的另一次大躍進，其特性如結構化綁定和 if constexpr 大幅減少了樣板程式碼，提升了程式碼的清晰度。

### **第六節：用於穩健程式設計的現代詞彙類型**

本節聚焦於標準函式庫中新增的強大「詞彙類型」（vocabulary types），它們為常見的程式設計問題（如可選值、非擁有視圖和可辨識聯合體）提供了標準化、類型安全的解決方案。

#### **6.1 非擁有視圖：string_view 與 span**

- **std::string_view (C++17)**：一個非擁有、唯讀的連續字元序列視圖。它解決了在傳遞子字串或唯讀字串資料時，因 std::string 複製而產生的高昂成本問題。使用 string_view 的一個關鍵點是必須謹慎管理其所指向的底層字串的生命週期，以避免懸掛指標（dangling pointers）99。
- **std::span (C++20)**：string_view 對任意連續物件序列的泛化。它是一個非擁有的陣列、std::vector 或 std::array 視圖，提供帶邊界檢查的存取，而沒有容器的開銷。它是向函數傳遞「指標加長度」這對資訊的現代、安全方式 101。

#### **6.2 和類型與積類型：optional、variant 與 any**

- **std::optional (C++17)**：表示一個可能存在也可能不存在的值。它是使用哨兵值（sentinel values）或空指標來表示失敗或結果缺失的類型安全替代方案。它在函數的返回類型中明確地傳達了「無值」的可能性 103。
- **std::variant (C++17)**：一個類型安全的可辨識聯合體（discriminated union）。variant 的實例在任何時候都持有其指定的可選類型之一的值。它提供了如 std::holds_alternative 和 std::get 等機制來安全地檢查和存取當前活動的類型，從而避免了 C 風格聯合體常見的未定義行為 104。
- **std::any (C++17)**：一個用於儲存任意單一可複製建構類型值的類型安全容器。它是一個類型抹除（type-erased）的包裝器，適用於需要儲存異質類型的場景。必須使用 std::any_cast 來取回值，如果類型不匹配，它會拋出 std::bad_any_cast 異常，從而確保類型安全 106。

#### **6.3 錯誤處理：std::expected (C++23)**

- **核心概念**：std::expected<T, E> 表示一個值，它要麼是一個期望的結果（類型為 T），要麼是一個非預期的錯誤（類型為 E）。對於可恢復的錯誤，它提供了一個強大的異常替代方案，使錯誤通道成為函數返回類型的一個明確部分 109。
- **比較**：報告將比較其與 std::optional（無法攜帶錯誤資訊）和異常（更適用於不可恢復的、異常的控制流）的使用場景。

這些詞彙類型的引入標誌著向基於值、具表達力的程式設計的重大轉變。現代 C++ 鼓勵返回豐富、自我說明的類型，如 std::optional<T> 或 std::expected<T, E>，而不是傳遞指標和布林標誌。這使得函數簽名能更誠實地反映其功能和可能的失敗情況，從而提高了程式碼的清晰度。

### **第七節：C++20 的「四大特性」與 C++23 的精煉**

本節涵蓋了最新 C++ 標準中最具變革性的特性，這些特性正在重塑 C++ 程式碼的編寫、編譯和執行方式。

#### **7.1 三向比較運算子 (<=>) (C++20)**

- **核心概念**：「太空船運算子」（spaceship operator）<=> 執行單一的三向比較，確定 a < b、a == b 還是 a > b。其返回類型（例如 std::strong_ordering）捕捉了比較的結果 111。
- **減少樣板程式碼**：透過定義或預設 operator<=>，編譯器可以自動產生所有六個關係運算子（==、!=、<、>、<=、>=），極大地減少了自訂類型的樣板程式碼 112。

#### **7.2 模組 (Modules) (C++20)**

- **解決的問題**：模組是基於預處理器的 #include 系統的現代替代方案。它們解決了標頭檔的主要問題，包括編譯時間長、巨集洩漏以及因包含順序而導致的脆弱性 114。
- **結構**：報告將解釋關鍵組件：模組介面單元（.ixx）、實作單元（.cpp）、export 和 import 關鍵字，以及分割區（partitions）的概念 114。

#### **7.3 協程 (Coroutines) (C++20/23)**

- **核心概念**：協程是可以被暫停和恢復的函數。C++20 提供了底層框架，包括 co_await、co_yield 和 co_return 關鍵字 118。
- **std::generator (C++23)**：標準函式庫中的第一個具體協程類型。它簡化了使用 co_yield 產生值序列的生成器函數的創建 120。

#### **7.4 C++23 語言精煉**

- **推導 this (Deducing this)**：允許將隱含的 this 指標變為成員函數的第一個顯式、模板化的參數（例如 void func(this Self&& self)）。這解決了編寫完美轉發和常數正確性成員函數的長期問題，並簡化了 CRTP 等模式 123。
- **explicit(bool)**：允許建構函式或轉換運算子根據一個編譯期布林條件來決定是否為 explicit。這為實現條件式顯式建構函式提供了一種直接、清晰的方式 127。
- **static operator()**：允許 operator() 被宣告為 static。這使得創建無狀態的可呼叫物件成為可能，並允許無捕獲的 lambda 成為 static，從而增加優化機會 129。

三向比較運算子和推導 this 等特性旨在消除大量重複、易錯的樣板程式碼。協程為 C++ 中的非同步程式設計新模型奠定了語言級基礎。而模組則是對 C++ 編譯模型自創立以來最重大的改變，它從根本上修復了老舊、脆弱且低效的預處理器包含系統，確保了 C++ 在大規模軟體開發中的長期生存能力。

### **結論**

從 C++11 到 C++23，C++ 語言經歷了一場深刻的轉型。這場轉型的核心驅動力是將更多的複雜性從執行期轉移到編譯期，並為開發者提供更安全、更具表達力、更少樣板程式碼的工具。

類型系統的革命，以 auto、decltype 和 decltype(auto) 為代表，使泛型程式碼的編寫變得更加精確和簡潔。編譯期程式設計能力的擴展，從 constexpr 的放寬到 consteval 和 constinit 的引入，不僅僅是為了優化，更是催生了一個強大的「編譯期 C++」子語言。

模板程式設計的演進，從神秘的 SFINAE 到清晰的 Concepts，標誌著 C++ 在提升開發者體驗和改善錯誤診斷方面的重大進步。這使得模板這一 C++ 最強大的特性，對於更廣泛的開發者社群來說，變得更加平易近人。

與此同時，標準函式庫的擴充，引入了如 std::optional、std::variant、std::string_view 和 std::span 等一系列強大的詞彙類型，這些類型鼓勵開發者編寫更具表達力、更安全且性能更高的程式碼。它們將常見的設計模式提升為一等語言公民，減少了對原始指標和手動狀態管理的依賴。

最後，C++20 和 C++23 的重大特性——模組、協程、三向比較和推導 this——正在從根本上重塑 C++ 的生態系統。模組修復了數十年來的編譯模型缺陷，協程為非同步程式設計開闢了新天地，而其他語言特性則持續致力於消除樣板程式碼，讓開發者能更專注於核心業務邏輯。

總體而言，現代 C++ 是一門在不斷演進中追求更高抽象層次、更強安全保證和極致性能的語言。掌握這些現代特性，對於任何希望在當今複雜的軟體工程環境中保持競爭力的 C++ 開發者來說，都是至關重要的。

#### **Works cited**

1.  auto (C++) | Microsoft Learn, accessed July 5, 2025, [https://learn.microsoft.com/en-us/cpp/cpp/auto-cpp?view=msvc-170](https://learn.microsoft.com/en-us/cpp/cpp/auto-cpp?view=msvc-170)
2.  C++ 11 Auto: How to use and avoid abuse - A CODERS JOURNEY, accessed July 5, 2025, [https://acodersjourney.com/c-11-auto/](https://acodersjourney.com/c-11-auto/)
3.  Using auto keyword whenever possible in C++11 | by Sreenath | Medium, accessed July 5, 2025, [https://medium.com/@mopurisreenath/using-auto-keyword-whenever-possible-in-c-11-653acb7008e2](https://medium.com/@mopurisreenath/using-auto-keyword-whenever-possible-in-c-11-653acb7008e2)
4.  What is the relation between auto and decltype in C++?, accessed July 5, 2025, [https://www.tutorialspoint.com/what-is-the-relation-between-auto-and-decltype-in-cplusplus](https://www.tutorialspoint.com/what-is-the-relation-between-auto-and-decltype-in-cplusplus)
5.  c++ - What is the difference between decltype and auto as a ..., accessed July 5, 2025, [https://stackoverflow.com/questions/12084040/what-is-the-difference-between-decltype-and-auto-as-a-placeholder-type-for-varia](https://stackoverflow.com/questions/12084040/what-is-the-difference-between-decltype-and-auto-as-a-placeholder-type-for-varia)
6.  Type Inference in C++ (auto and decltype) - GeeksforGeeks, accessed July 5, 2025, [https://www.geeksforgeeks.org/type-inference-in-c-auto-and-decltype/](https://www.geeksforgeeks.org/type-inference-in-c-auto-and-decltype/)
7.  What is decltype and how is it used? - Stack Overflow, accessed July 5, 2025, [https://stackoverflow.com/questions/18815221/what-is-decltype-and-how-is-it-used](https://stackoverflow.com/questions/18815221/what-is-decltype-and-how-is-it-used)
8.  decltype specifier (since C++11) - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/language/decltype.html](https://en.cppreference.com/w/cpp/language/decltype.html)
9.  Modern C++ Features - decltype and std::declval - Simplify C++!, accessed July 5, 2025, [https://arne-mertz.de/2017/01/decltype-declval/](https://arne-mertz.de/2017/01/decltype-declval/)
10. C++ value categories and decltype demystified, accessed July 5, 2025, [https://www.scs.stanford.edu/~dm/blog/decltype.html](https://www.scs.stanford.edu/~dm/blog/decltype.html)
11. How does decltype(auto) make sense? : r/cpp_questions - Reddit, accessed July 5, 2025, [https://www.reddit.com/r/cpp_questions/comments/1ed9wz2/how_does_decltypeauto_make_sense/](https://www.reddit.com/r/cpp_questions/comments/1ed9wz2/how_does_decltypeauto_make_sense/)
12. Placeholder type specifiers (since C++11) - cppreference.com - C++ Reference, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/language/auto.html](https://en.cppreference.com/w/cpp/language/auto.html)
13. C++: Return Type "auto" | DICE Research Group, accessed July 5, 2025, [https://dice-research.org/news/2022-04-08_cpp_return_type_auto/](https://dice-research.org/news/2022-04-08_cpp_return_type_auto/)
14. auto vrs decltype(auto) - C++ Forum - CPlusPlus.com, accessed July 5, 2025, [https://cplusplus.com/forum/general/186478/](https://cplusplus.com/forum/general/186478/)
15. When to use decltype(auto) versus auto? - C++ Forum, accessed July 5, 2025, [https://cplusplus.com/forum/general/188645/](https://cplusplus.com/forum/general/188645/)
16. std::declval - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/utility/declval.html](https://en.cppreference.com/w/cpp/utility/declval.html)
17. Understand declval and decltype - SoByte, accessed July 5, 2025, [https://www.sobyte.net/post/2021-10/cplusplus-std-declval-and-decltype/](https://www.sobyte.net/post/2021-10/cplusplus-std-declval-and-decltype/)
18. In C++, what does std::declval
19. Daily bit(e) of C++ | std::declval | by Šimon Tóth - Medium, accessed July 5, 2025, [https://medium.com/@simontoth/daily-bit-e-of-c-std-declval-4a1583cb3b69](https://medium.com/@simontoth/daily-bit-e-of-c-std-declval-4a1583cb3b69)
20. The constexpr specifier (C++11) - IBM, accessed July 5, 2025, [https://www.ibm.com/docs/en/xl-c-and-cpp-aix/16.1.0?topic=declarations-constexpr-specifier-c11](https://www.ibm.com/docs/en/xl-c-and-cpp-aix/16.1.0?topic=declarations-constexpr-specifier-c11)
21. Understanding constexpr Specifier in C++ - GeeksforGeeks, accessed July 5, 2025, [https://www.geeksforgeeks.org/understanding-constexper-specifier-in-cpp/](https://www.geeksforgeeks.org/understanding-constexper-specifier-in-cpp/)
22. Constexpr functions (C++11) - IBM, accessed July 5, 2025, [https://www.ibm.com/docs/en/xl-c-and-cpp-aix/16.1.0?topic=functions-constexpr-c11](https://www.ibm.com/docs/en/xl-c-and-cpp-aix/16.1.0?topic=functions-constexpr-c11)
23. Constexpr functions (C++11) - IBM, accessed July 5, 2025, [https://www.ibm.com/docs/zh/ssw_ibm_i_74/rzarg/constexpr_functions.htm](https://www.ibm.com/docs/zh/ssw_ibm_i_74/rzarg/constexpr_functions.htm)
24. C++14 Language Extensions, C++ FAQ - Standard C++, accessed July 5, 2025, [https://isocpp.org/wiki/faq/cpp14-language](https://isocpp.org/wiki/faq/cpp14-language)
25. constexpr in C++ 11 and C++ 14 – Andrew Shitov, accessed July 5, 2025, [https://andrewshitov.com/2019/11/08/constexpr-in-cpp-11-and-cpp-14/](https://andrewshitov.com/2019/11/08/constexpr-in-cpp-11-and-cpp-14/)
26. c++ - consteval vs constexpr on variables - Stack Overflow, accessed July 5, 2025, [https://stackoverflow.com/questions/64395622/consteval-vs-constexpr-on-variables](https://stackoverflow.com/questions/64395622/consteval-vs-constexpr-on-variables)
27. constexpr and consteval Functions in C++20 – MC++ BLOG - Modernes C++, accessed July 5, 2025, [https://www.modernescpp.com/index.php/constexpr-and-consteval-functions-in-c-20/](https://www.modernescpp.com/index.php/constexpr-and-consteval-functions-in-c-20/)
28. Two new Keywords in C++20: consteval and constinit – MC++ BLOG, accessed July 5, 2025, [https://www.modernescpp.com/index.php/c-20-consteval-and-constinit/](https://www.modernescpp.com/index.php/c-20-consteval-and-constinit/)
29. What is `constinit` in C++20? - Stack Overflow, accessed July 5, 2025, [https://stackoverflow.com/questions/57845131/what-is-constinit-in-c20](https://stackoverflow.com/questions/57845131/what-is-constinit-in-c20)
30. constinit specifier (since C++20) - cppreference.com - C++ Reference, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/language/constinit.html](https://en.cppreference.com/w/cpp/language/constinit.html)
31. if constexpr in C++ 17 - GeeksforGeeks, accessed July 5, 2025, [https://www.geeksforgeeks.org/cpp/if-constexpr-in-cpp-17/](https://www.geeksforgeeks.org/cpp/if-constexpr-in-cpp-17/)
32. C++23: if consteval : Rangarajan Krishnamoorthy on Programming ..., accessed July 5, 2025, [https://www.rangakrish.com/index.php/2023/09/24/c23-if-consteval/](https://www.rangakrish.com/index.php/2023/09/24/c23-if-consteval/)
33. What is if consteval needed for? - c++ - Stack Overflow, accessed July 5, 2025, [https://stackoverflow.com/questions/68213012/what-is-if-consteval-needed-for](https://stackoverflow.com/questions/68213012/what-is-if-consteval-needed-for)
34. A quick primer on type traits in modern C++ - Internal Pointers, accessed July 5, 2025, [https://www.internalpointers.com/post/quick-primer-type-traits-modern-cpp](https://www.internalpointers.com/post/quick-primer-type-traits-modern-cpp)
35.
36. type_traits - cplusplus.com, accessed July 5, 2025, [https://cplusplus.com/reference/type_traits/](https://cplusplus.com/reference/type_traits/)
37. Standard library header
38. std::is_aggregate - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/types/is_aggregate.html](https://en.cppreference.com/w/cpp/types/is_aggregate.html)
39. std::is_bounded_array - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/types/is_bounded_array.html](https://en.cppreference.com/w/cpp/types/is_bounded_array.html)
40. std::is_trivially_copyable - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/types/is_trivially_copyable.html](https://en.cppreference.com/w/cpp/types/is_trivially_copyable.html)
41. std::is_layout_compatible - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/types/is_layout_compatible.html](https://en.cppreference.com/w/cpp/types/is_layout_compatible.html)
42. std::remove_reference - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/types/remove_reference.html](https://en.cppreference.com/w/cpp/types/remove_reference.html)
43. Std::remove_reference - C++ - W3cubDocs, accessed July 5, 2025, [https://docs1.w3cub.com/cpp/types/remove_reference/](https://docs1.w3cub.com/cpp/types/remove_reference/)
44. std::remove_cvref - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/types/remove_cvref.html](https://en.cppreference.com/w/cpp/types/remove_cvref.html)
45. std::decay - cppreference.com - Mooshak, accessed July 5, 2025, [https://mooshak.dcc.fc.up.pt/~oni-judge/doc/cppreference/reference/en/cpp/types/decay.html](https://mooshak.dcc.fc.up.pt/~oni-judge/doc/cppreference/reference/en/cpp/types/decay.html)
46. c++ - Why does make_optional decay its argument type? - Stack ..., accessed July 5, 2025, [https://stackoverflow.com/questions/24557000/why-does-make-optional-decay-its-argument-type](https://stackoverflow.com/questions/24557000/why-does-make-optional-decay-its-argument-type)
47. what exactly is std::decay used for? : r/cpp_questions - Reddit, accessed July 5, 2025, [https://www.reddit.com/r/cpp_questions/comments/mllfdw/what_exactly_is_stddecay_used_for/](https://www.reddit.com/r/cpp_questions/comments/mllfdw/what_exactly_is_stddecay_used_for/)
48. std::conditional - CPlusPlus.com, accessed July 5, 2025, [https://cplusplus.com/reference/type_traits/conditional/](https://cplusplus.com/reference/type_traits/conditional/)
49. std::conditional - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/types/conditional.html](https://en.cppreference.com/w/cpp/types/conditional.html)
50. std::common_type - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/types/common_type.html](https://en.cppreference.com/w/cpp/types/common_type.html)
51. std::common_type - cppreference.com, accessed July 5, 2025, [http://naipc.uchicago.edu/2015/ref/cppreference/en/cpp/types/common_type.html](http://naipc.uchicago.edu/2015/ref/cppreference/en/cpp/types/common_type.html)
52. std::result_of, std::invoke_result - cppreference.com - Mooshak, accessed July 5, 2025, [https://mooshak.dcc.fc.up.pt/~aed/reference/en/cpp/types/result_of.html](https://mooshak.dcc.fc.up.pt/~aed/reference/en/cpp/types/result_of.html)
53. std::result_of, std::invoke_result - cppreference.com, accessed July 5, 2025, [https://saco-evaluator.org.za/docs/cppreference/en/cpp/types/result_of.html](https://saco-evaluator.org.za/docs/cppreference/en/cpp/types/result_of.html)
54. std::invoke - cppreference.com, accessed July 5, 2025, [https://saco-evaluator.org.za/docs/cppreference/en/cpp/utility/functional/invoke.html](https://saco-evaluator.org.za/docs/cppreference/en/cpp/utility/functional/invoke.html)
55. result_of, std::invoke_result - C++ - W3cubDocs, accessed July 5, 2025, [https://docs3.w3cub.com/cpp/types/result_of/](https://docs3.w3cub.com/cpp/types/result_of/)
56. Tutorial: Let's get comfortable with SFINAE - Dimitris Platis, accessed July 5, 2025, [https://platis.solutions/blog/2024/01/27/lets-get-comfortable-with-sfinae/](https://platis.solutions/blog/2024/01/27/lets-get-comfortable-with-sfinae/)
57. SFINAE and enable_if - Eli Bendersky's website, accessed July 5, 2025, [https://eli.thegreenplace.net/2014/sfinae-and-enable_if/](https://eli.thegreenplace.net/2014/sfinae-and-enable_if/)
58. An introduction to C++'s SFINAE concept: compile-time introspection of a class member, accessed July 5, 2025, [https://jguegant.github.io/blogs/tech/sfinae-introduction.html](https://jguegant.github.io/blogs/tech/sfinae-introduction.html)
59. C++ Templates: What is std::enable_if and how to use it? | by Siddharth Bhasin | Medium, accessed July 5, 2025, [https://medium.com/@sidbhasin82/c-templates-what-is-std-enable-if-and-how-to-use-it-fd76d3abbabe](https://medium.com/@sidbhasin82/c-templates-what-is-std-enable-if-and-how-to-use-it-fd76d3abbabe)
60. How to Make SFINAE Pretty - Part 1: What SFINAE Brings to Code ..., accessed July 5, 2025, [https://www.fluentcpp.com/2018/05/15/make-sfinae-pretty-1-what-value-sfinae-brings-to-code/](https://www.fluentcpp.com/2018/05/15/make-sfinae-pretty-1-what-value-sfinae-brings-to-code/)
61. C++ 20 Concepts: part 1 (the basics) | by Gajendra Gulgulia - Medium, accessed July 5, 2025, [https://ggulgulia.medium.com/c-20-concepts-part-1-the-basics-40f051c72776](https://ggulgulia.medium.com/c-20-concepts-part-1-the-basics-40f051c72776)
62. Constraints and concepts (since C++20) - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/language/constraints.html](https://en.cppreference.com/w/cpp/language/constraints.html)
63. C++ 20 Concepts Introduction - Part 1 of n | Modern Cpp Series - YouTube, accessed July 5, 2025, [https://www.youtube.com/watch?v=VTweta35r_A](https://www.youtube.com/watch?v=VTweta35r_A)
64. Concepts versus SFINAE-based constraints - Marius Bancila's Blog, accessed July 5, 2025, [https://mariusbancila.ro/blog/2019/10/04/concepts-versus-sfinae-based-constraints/](https://mariusbancila.ro/blog/2019/10/04/concepts-versus-sfinae-based-constraints/)
65. How would a better SFINAE go? Is it just Concepts? : r/cpp - Reddit, accessed July 5, 2025, [https://www.reddit.com/r/cpp/comments/4465zg/how_would_a_better_sfinae_go_is_it_just_concepts/](https://www.reddit.com/r/cpp/comments/4465zg/how_would_a_better_sfinae_go_is_it_just_concepts/)
66. c++ - Is concept a variant of SFINAE - Stack Overflow, accessed July 5, 2025, [https://stackoverflow.com/questions/74514843/is-concept-a-variant-of-sfinae](https://stackoverflow.com/questions/74514843/is-concept-a-variant-of-sfinae)
67. Concepts Lite vs enable_if | Andrzej's C++ blog - WordPress.com, accessed July 5, 2025, [https://akrzemi1.wordpress.com/2016/09/21/concepts-lite-vs-enable_if/](https://akrzemi1.wordpress.com/2016/09/21/concepts-lite-vs-enable_if/)
68. Why does the C++20 "requires" keyword have two distinct meanings : r/cpp - Reddit, accessed July 5, 2025, [https://www.reddit.com/r/cpp/comments/10c6f6w/why_does_the_c20_requires_keyword_have_two/](https://www.reddit.com/r/cpp/comments/10c6f6w/why_does_the_c20_requires_keyword_have_two/)
69. requires expressions and requires clauses in C++20 - Marius Bancila's Blog, accessed July 5, 2025, [https://mariusbancila.ro/blog/2022/06/20/requires-expressions-and-requires-clauses-in-cpp20/](https://mariusbancila.ro/blog/2022/06/20/requires-expressions-and-requires-clauses-in-cpp20/)
70. requires expression (since C++20) - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/language/requires.html](https://en.cppreference.com/w/cpp/language/requires.html)
71. C++20 Requires Expressions - YouTube, accessed July 5, 2025, [https://www.youtube.com/watch?v=tmuUSoI6gQM](https://www.youtube.com/watch?v=tmuUSoI6gQM)
72. NULL vs nullptr | Sololearn: Learn to code for FREE!, accessed July 5, 2025, [https://www.sololearn.com/en/Discuss/3097671/null-vs-nullptr](https://www.sololearn.com/en/Discuss/3097671/null-vs-nullptr)
73. Migrating from C to C++: NULL vs nullptr - Embedded Artistry, accessed July 5, 2025, [https://embeddedartistry.com/blog/2017/03/08/migrating-from-c-to-c-null-vs-nullptr/](https://embeddedartistry.com/blog/2017/03/08/migrating-from-c-to-c-null-vs-nullptr/)
74. Understanding static_assert in C++ 11 - GeeksforGeeks, accessed July 5, 2025, [https://www.geeksforgeeks.org/cpp/understanding-static_assert-c-11/](https://www.geeksforgeeks.org/cpp/understanding-static_assert-c-11/)
75. What does static_assert do, and what would you use it for? - Stack Overflow, accessed July 5, 2025, [https://stackoverflow.com/questions/1647895/what-does-static-assert-do-and-what-would-you-use-it-for](https://stackoverflow.com/questions/1647895/what-does-static-assert-do-and-what-would-you-use-it-for)
76. static_assert declaration (C++11) - IBM, accessed July 5, 2025, [https://www.ibm.com/docs/en/i/7.4.0?topic=declarations-static-assert-declaration-c11](https://www.ibm.com/docs/en/i/7.4.0?topic=declarations-static-assert-declaration-c11)
77. 25.3 — The override and final specifiers, and covariant return types ..., accessed July 5, 2025, [https://www.learncpp.com/cpp-tutorial/the-override-and-final-specifiers-and-covariant-return-types/](https://www.learncpp.com/cpp-tutorial/the-override-and-final-specifiers-and-covariant-return-types/)
78. C++ final Specifier - GeeksforGeeks, accessed July 5, 2025, [https://www.geeksforgeeks.org/c-final-specifier/](https://www.geeksforgeeks.org/c-final-specifier/)
79. Explicitly Defaulted and Deleted Functions | Microsoft Learn, accessed July 5, 2025, [https://learn.microsoft.com/en-us/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-170](https://learn.microsoft.com/en-us/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-170)
80. abseil / Tip of the Week #143: C++11 Deleted Functions (= delete), accessed July 5, 2025, [https://abseil.io/tips/143](https://abseil.io/tips/143)
81. Explicitly defaulted functions (C++11) - IBM, accessed July 5, 2025, [https://www.ibm.com/docs/ssw_ibm_i_74/rzarg/defaulted_functions.htm](https://www.ibm.com/docs/ssw_ibm_i_74/rzarg/defaulted_functions.htm)
82. thread_local Storage in C++ 11 - GeeksforGeeks, accessed July 5, 2025, [https://www.geeksforgeeks.org/cpp/thread_local-storage-in-cpp-11/](https://www.geeksforgeeks.org/cpp/thread_local-storage-in-cpp-11/)
83. Thread-local storage - Wikipedia, accessed July 5, 2025, [https://en.wikipedia.org/wiki/Thread-local_storage](https://en.wikipedia.org/wiki/Thread-local_storage)
84. Thread Local Storage (TLS) - Learn Microsoft, accessed July 5, 2025, [https://learn.microsoft.com/en-us/cpp/parallel/thread-local-storage-tls?view=msvc-170](https://learn.microsoft.com/en-us/cpp/parallel/thread-local-storage-tls?view=msvc-170)
85. \_Alignas (since C11)(deprecated in C23), alignas (since C23) - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/c/language/alignas.html](https://en.cppreference.com/w/c/language/alignas.html)
86. alignas specifier (since C++11) - cppreference.com - C++ Reference, accessed July 5, 2025, [http://en.cppreference.com/w/cpp/language/alignas.html](http://en.cppreference.com/w/cpp/language/alignas.html)
87. alignof operator (since C++11) - cppreference.com - C++ Reference, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/language/alignof.html](https://en.cppreference.com/w/cpp/language/alignof.html)
88. alignas specifier (since C++11) - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/language/alignas.html](https://en.cppreference.com/w/cpp/language/alignas.html)
89. C++ Inline Namespaces and Usage of the "using" Directive Inside ..., accessed July 5, 2025, [https://www.geeksforgeeks.org/cpp/cpp-inline-namespaces-and-usage-of-the-using-directive-inside-namespaces/](https://www.geeksforgeeks.org/cpp/cpp-inline-namespaces-and-usage-of-the-using-directive-inside-namespaces/)
90. Inline namespace definitions (C++11) - IBM, accessed July 5, 2025, [https://www.ibm.com/docs/SSLTBW_2.4.0/com.ibm.zos.v2r4.cbclx01/namespace_association.htm](https://www.ibm.com/docs/SSLTBW_2.4.0/com.ibm.zos.v2r4.cbclx01/namespace_association.htm)
91. What are inline namespaces for? - Stack Overflow, accessed July 5, 2025, [https://stackoverflow.com/questions/11016220/what-are-inline-namespaces-for](https://stackoverflow.com/questions/11016220/what-are-inline-namespaces-for)
92. How Generic Lambda Works in C++14 - Tutorialspoint, accessed July 5, 2025, [https://www.tutorialspoint.com/how-does-generic-lambda-work-in-cplusplus14](https://www.tutorialspoint.com/how-does-generic-lambda-work-in-cplusplus14)
93. Generic Lambda C++14, With Example (Custom Sort String) | by Everything is MindGame, accessed July 5, 2025, [https://medium.com/@everythingismindgame/generic-lambda-c-14-with-example-custom-sort-a3158a726ac9](https://medium.com/@everythingismindgame/generic-lambda-c-14-with-example-custom-sort-a3158a726ac9)
94. Introducing C++14's Binary Literals, Digit Separators, and Variable, accessed July 5, 2025, [https://www.informit.com/articles/article.aspx?p=2209021](https://www.informit.com/articles/article.aspx?p=2209021)
95. www.informit.com, accessed July 5, 2025, [https://www.informit.com/articles/article.aspx?p=2209021#:~:text=You%20can%20now%20use%20binary,digits%2C%20namely%200%20and%201.](https://www.informit.com/articles/article.aspx?p=2209021#:~:text=You%20can%20now%20use%20binary,digits%2C%20namely%200%20and%201.)
96. cpp14 language - Standard C++, accessed July 5, 2025, [https://isocpp.org/wiki/faq/cpp14-language%5C](https://isocpp.org/wiki/faq/cpp14-language%5C)
97. Structured bindings in C++17, 5 years later - C++ Stories, accessed July 5, 2025, [https://www.cppstories.com/2022/structured-bindings/](https://www.cppstories.com/2022/structured-bindings/)
98. A brief introduction to C++ structured binding - The Old New Thing, accessed July 5, 2025, [https://devblogs.microsoft.com/oldnewthing/20201014-00/?p=104367](https://devblogs.microsoft.com/oldnewthing/20201014-00/?p=104367)
99. std::basic_string_view
100.  std::basic_string_view - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/string/basic_string_view.html](https://en.cppreference.com/w/cpp/string/basic_string_view.html)
101.  c++ - What is a "span" and when should I use one? - Stack Overflow, accessed July 5, 2025, [https://stackoverflow.com/questions/45723819/what-is-a-span-and-when-should-i-use-one](https://stackoverflow.com/questions/45723819/what-is-a-span-and-when-should-i-use-one)
102.  std::span - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/container/span.html](https://en.cppreference.com/w/cpp/container/span.html)
103.  std::optional - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/utility/optional.html](https://en.cppreference.com/w/cpp/utility/optional.html)
104.  std::variant - cppreference.com - Mooshak, accessed July 5, 2025, [https://mooshak.dcc.fc.up.pt/~oni-judge/doc/cppreference/reference/en/cpp/utility/variant.html](https://mooshak.dcc.fc.up.pt/~oni-judge/doc/cppreference/reference/en/cpp/utility/variant.html)
105.  std::variant - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/utility/variant.html](https://en.cppreference.com/w/cpp/utility/variant.html)
106.  std::any - cppreference.com, accessed July 5, 2025, [http://en.cppreference.com/w/cpp/utility/any.html](http://en.cppreference.com/w/cpp/utility/any.html)
107.  std::any_cast - cppreference.com - C++ Reference, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/utility/any/any_cast](https://en.cppreference.com/w/cpp/utility/any/any_cast)
108.  std::any - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/utility/any.html](https://en.cppreference.com/w/cpp/utility/any.html)
109.  operator==(std::expected) - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/utility/expected/operator_cmp](https://en.cppreference.com/w/cpp/utility/expected/operator_cmp)
110.  Have you tried `std::expected` in C++23? It's much better than handling exceptions. - Reddit, accessed July 5, 2025, [https://www.reddit.com/r/devsarg/comments/1im6k1b/probaron_stdexpected_en_c23_es_mucho_mejor_que/?tl=en](https://www.reddit.com/r/devsarg/comments/1im6k1b/probaron_stdexpected_en_c23_es_mucho_mejor_que/?tl=en)
111.  devblogs.microsoft.com, accessed July 5, 2025, [https://devblogs.microsoft.com/oldnewthing/20220516-52/?p=106661#:~:text=The%20C%2B%2B20%20three,equivalent%2C%20greater%2C%20and%20unordered.](https://devblogs.microsoft.com/oldnewthing/20220516-52/?p=106661#:~:text=The%20C%2B%2B20%20three,equivalent%2C%20greater%2C%20and%20unordered.)
112.  C++20: The Three-Way Comparison Operator – MC++ BLOG, accessed July 5, 2025, [https://www.modernescpp.com/index.php/c-20-the-three-way-comparison-operator/](https://www.modernescpp.com/index.php/c-20-the-three-way-comparison-operator/)
113.  C++20: More Details to the Spaceship Operator - Modernes C++, accessed July 5, 2025, [https://www.modernescpp.com/index.php/c-20-more-details-to-the-spaceship-operator/](https://www.modernescpp.com/index.php/c-20-more-details-to-the-spaceship-operator/)
114.  Named modules tutorial in C++ | Microsoft Learn, accessed July 5, 2025, [https://learn.microsoft.com/en-us/cpp/cpp/tutorial-named-modules-cpp?view=msvc-170](https://learn.microsoft.com/en-us/cpp/cpp/tutorial-named-modules-cpp?view=msvc-170)
115.  Modules in C++ 20 - GeeksforGeeks, accessed July 5, 2025, [https://www.geeksforgeeks.org/cpp/modules-in-cpp-20/](https://www.geeksforgeeks.org/cpp/modules-in-cpp-20/)
116.  Overview of modules in C++ | Microsoft Learn, accessed July 5, 2025, [https://learn.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-170](https://learn.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-170)
117.  Modules (since C++20) - cppreference.com - C++ Reference, accessed July 5, 2025, [https://cppreference.com/w/cpp/language/modules.html](https://cppreference.com/w/cpp/language/modules.html)
118.  Coroutines (C++20) - cppreference.com, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/language/coroutines.html](https://en.cppreference.com/w/cpp/language/coroutines.html)
119.  C++20 coroutine tutorial - GitHub, accessed July 5, 2025, [https://github.com/Atliac/Coroutine-Tutorial](https://github.com/Atliac/Coroutine-Tutorial)
120.  std::generator: Standard Library Coroutine Support - C++ Team Blog, accessed July 5, 2025, [https://devblogs.microsoft.com/cppblog/std-generator-standard-library-coroutine-support/](https://devblogs.microsoft.com/cppblog/std-generator-standard-library-coroutine-support/)
121.  Daily bit(e) of C++ | std::generator | by Šimon Tóth - Medium, accessed July 5, 2025, [https://medium.com/@simontoth/daily-bit-e-of-c-std-generator-509d1e004e6c](https://medium.com/@simontoth/daily-bit-e-of-c-std-generator-509d1e004e6c)
122.  C++23: Ranges Improvements and std::generator – MC++ BLOG - Modernes C++, accessed July 5, 2025, [https://www.modernescpp.com/index.php/c23-ranges-improvements-and-stdgenerator/](https://www.modernescpp.com/index.php/c23-ranges-improvements-and-stdgenerator/)
123.  std::generator
124.  C++23: What Is "Deducing This"? - GitHub Gist, accessed July 5, 2025, [https://gist.github.com/MangaD/a5c5d430f8ef0d791b5a4f6664da1b95](https://gist.github.com/MangaD/a5c5d430f8ef0d791b5a4f6664da1b95)
125.  Deducing this - Open Standards, accessed July 5, 2025, [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html)
126.  C++23: Syntactic Sugar with Deducing This : r/cpp - Reddit, accessed July 5, 2025, [https://www.reddit.com/r/cpp/comments/158794u/c23_syntactic_sugar_with-deducing-this/](https://www.reddit.com/r/cpp/comments/158794u/c23_syntactic_sugar-with-deducing-this/)
127.  explicit(bool) - Open Standards, accessed July 5, 2025, [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0892r2.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0892r2.html)
128.  explicit specifier - cppreference.com - C++ Reference, accessed July 5, 2025, [https://en.cppreference.com/w/cpp/language/explicit.html](https://en.cppreference.com/w/cpp/language/explicit.html)
129.  106651 – [C++23] P1169 - static operator(), accessed July 5, 2025, [https://gcc.gnu.org/PR106651](https://gcc.gnu.org/PR106651)
